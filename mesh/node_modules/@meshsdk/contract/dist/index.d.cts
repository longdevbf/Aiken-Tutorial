import * as _meshsdk_common from '@meshsdk/common';
import { ConStr0 as ConStr0$1, PubKeyAddress, Value, ConStr1, Integer as Integer$1, CurrencySymbol, TokenName, AssetMetadata, Asset as Asset$1, UTxO as UTxO$1, BuiltinByteString as BuiltinByteString$1 } from '@meshsdk/common';
import { MeshTxBuilder, IFetcher, IWallet, LanguageVersion, UTxO, ConStr0, BuiltinByteString, ScriptAddress, Integer, NativeScript, Asset } from '@meshsdk/core';

type MeshTxInitiatorInput = {
    mesh: MeshTxBuilder;
    fetcher?: IFetcher;
    wallet?: IWallet;
    networkId?: number;
    stakeCredential?: string;
    version?: number;
};
declare class MeshTxInitiator {
    mesh: MeshTxBuilder;
    fetcher?: IFetcher;
    wallet?: IWallet;
    stakeCredential?: string;
    networkId: number;
    version: number;
    languageVersion: LanguageVersion;
    constructor({ mesh, fetcher, wallet, networkId, stakeCredential, version, }: MeshTxInitiatorInput);
    getScriptAddress: (scriptCbor: string) => string;
    protected signSubmitReset: () => Promise<string | undefined>;
    protected queryUtxos: (walletAddress: string) => Promise<UTxO[]>;
    protected getWalletDappAddress: () => Promise<string | undefined>;
    protected getWalletCollateral: () => Promise<UTxO | undefined>;
    protected getWalletUtxosWithMinLovelace: (lovelace: number, providedUtxos?: UTxO[]) => Promise<UTxO[]>;
    protected getWalletUtxosWithToken: (assetHex: string, userUtxos?: UTxO[]) => Promise<UTxO[]>;
    protected getAddressUtxosWithMinLovelace: (walletAddress: string, lovelace: number, providedUtxos?: UTxO[]) => Promise<UTxO[]>;
    protected getAddressUtxosWithToken: (walletAddress: string, assetHex: string, userUtxos?: UTxO[]) => Promise<UTxO[]>;
    protected getWalletInfoForTx: () => Promise<{
        utxos: UTxO[];
        collateral: UTxO;
        walletAddress: string;
    }>;
    protected _getUtxoByTxHash: (txHash: string, scriptCbor?: string) => Promise<UTxO | undefined>;
}

type ScriptIndex = "OracleNFT" | "OracleValidator" | "ContentRegistry" | "ContentRefToken" | "OwnershipRegistry" | "OwnershipRefToken";

type OracleDatum = ConStr0<[
    BuiltinByteString,
    ScriptAddress,
    BuiltinByteString,
    ScriptAddress,
    Integer,
    BuiltinByteString,
    ScriptAddress,
    Integer,
    BuiltinByteString,
    BuiltinByteString
]>;
type UpdateContent = {
    ownerTokenUtxo: UTxO;
    registryNumber: number;
    newContentHashHex: string;
    contentNumber: number;
};
type TransferContent = {
    ownerTokenUtxo: UTxO;
    registryNumber: number;
    newOwnerAssetHex: string;
    contentNumber: number;
};

/**
 * Mesh Content Ownership Contract
 *
 * This contract is used to manage the ownership of content.
 * It facilitates on-chain record of content (i.e. file on IPFS) ownership and transfer.
 * While one cannot prefer others from obtaining a copy of the content, the app owner of the
 * contract can serve the single source of truth of who owns the content. With the blockchain
 * trace and record in place, it provides a trustless way to verify the ownership of the content
 * and facilitates further application logics such as royalties, licensing, etc.
 *
 * @example
 * ```typescript
 *  const meshTxBuilder = new MeshTxBuilder({
 *   fetcher: blockchainProvider, // one of the Providers
 *   submitter: blockchainProvider,
 *   verbose: true,
 * });
 *
 * const contract = new MeshContentOwnershipContract(
 *   {
 *     mesh: meshTxBuilder,
 *     fetcher: blockchainProvider,
 *     wallet: wallet,
 *     networkId: 0,
 *   },
 *   {
 *     operationAddress: operationAddress, // the address of the app owner, where most of the actions should be signed by the spending key of this address
 *     paramUtxo: { outputIndex: 0, txHash: "0000000000000000000000000000000000000000000000000000000000000000" }, // you can get this from the output of `mintOneTimeMintingPolicy()` transaction
 *     refScriptUtxos?: { // you can get these from the output of `sendRefScriptOnchain()` transactions
 *       contentRegistry: { outputIndex: 0, txHash: "0000000000000000000000000000000000000000000000000000000000000000" },
 *       contentRefToken: { outputIndex: 0, txHash: "0000000000000000000000000000000000000000000000000000000000000000" },
 *       ownershipRegistry: { outputIndex: 0, txHash: "0000000000000000000000000000000000000000000000000000000000000000" },
 *       ownershipRefToken: { outputIndex: 0, txHash: "0000000000000000000000000000000000000000000000000000000000000000" },
 *     },
 *   },
 * );
 * ```
 */
declare class MeshContentOwnershipContract extends MeshTxInitiator {
    paramUtxo: {
        txHash: string;
        outputIndex: number;
    };
    scriptInfo: {
        oracleNFT: {
            hash: string;
            cbor: string;
        };
        oracleValidator: {
            hash: string;
            cbor: string;
            address: string;
        };
        contentRegistry: {
            hash: string;
            cbor: string;
            address: string;
        };
        contentRefToken: {
            hash: string;
            cbor: string;
        };
        ownershipRegistry: {
            hash: string;
            cbor: string;
            address: string;
        };
        ownershipRefToken: {
            hash: string;
            cbor: string;
        };
    };
    refScriptUtxos: {
        contentRefToken: {
            txHash: string;
            outputIndex: number;
        };
        ownershipRefToken: {
            txHash: string;
            outputIndex: number;
        };
        contentRegistry: {
            txHash: string;
            outputIndex: number;
        };
        ownershipRegistry: {
            txHash: string;
            outputIndex: number;
        };
    };
    operationAddress: string;
    opsKey: string;
    constructor(inputs: MeshTxInitiatorInput, contract: {
        operationAddress: string;
        paramUtxo?: UTxO["input"];
        refScriptUtxos?: {
            contentRegistry: UTxO["input"];
            contentRefToken: UTxO["input"];
            ownershipRegistry: UTxO["input"];
            ownershipRefToken: UTxO["input"];
        };
    });
    getOwnerNativeScript: () => {
        nativeScript: {
            type: "all" | "any";
            scripts: NativeScript[];
        };
        scriptAddress: string;
    };
    /**
     * [Setup phase]
     * This is the first transaction you need to setup the contract.
     *
     * This transaction mints the one-time minting policy (a NFT) for the contract.
     * It will be attached with the datum which serves as the single source of truth for the contract oracle.
     *
     * Note: You must save the `paramUtxo` for future transactions.
     *
     * @returns {Promise<{ txHexMintOneTimeMintingPolicy: string, txHexSetupOracleUtxo: string, paramUtxo: UTxO["input"] }>}
     *
     * @example
     * ```typescript
     * const { tx, paramUtxo } = await contract.mintOneTimeMintingPolicy();
     * const signedTx = await wallet.signTx(tx);
     * const txHash = await wallet.submitTx(signedTx);
     * ```
     */
    mintOneTimeMintingPolicy: () => Promise<{
        tx: string;
        paramUtxo: {
            outputIndex: number;
            txHash: string;
        };
    }>;
    /**
     * [Setup phase]
     * This is the second transaction you need to setup the contract.
     *
     * This transaction send the NFT to a oracle contract locking the datum,
     * which serves as the single source of truth for the contract oracle with data integrity.
     *
     * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.
     *
     * @returns {Promise<string>}
     *
     * @example
     * ```typescript
     * const txHex = await contract.setupOracleUtxo();
     * const signedTx = await wallet.signTx(txHex);
     * const txHash = await wallet.submitTx(signedTx);
     * ```
     */
    setupOracleUtxo: () => Promise<string>;
    /**
     * [Setup phase]
     * This are the next transactions you need to setup the contract.
     * You need to run once for each script, and you would likely have to run one after the previous one is confirmed.
     *
     * This transaction sends the reference scripts to the blockchain for later transactions,
     * boosting efficiency and avoid exceeding 16kb of transaction size limits enforced by protocol parameter.
     *
     * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.
     * Note: You must save txHash (after signed and submitted) for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken` transactions for future transactions.
     *
     * @param scriptIndex - "OracleNFT" | "OracleValidator" | "ContentRegistry" | "ContentRefToken" | "OwnershipRegistry" | "OwnershipRefToken"
     * @returns {Promise<string>}
     *
     * @example
     * ```typescript
     * const txHexOracleNFT = await contract.sendRefScriptOnchain("OracleNFT");
     * const signedTxOracleNFT = await wallet.signTx(txHexOracleNFT);
     * const txHashOracleNFT = await wallet.submitTx(signedTxOracleNFT);
     *
     * const txHexOracleValidator = await contract.sendRefScriptOnchain("OracleValidator");
     * ... // repeat for each script
     *
     * const txHexOwnershipRefToken = await contract.sendRefScriptOnchain("OwnershipRefToken");
     * const signedTxOwnershipRefToken = await wallet.signTx(txHexOwnershipRefToken);
     * const txHashOwnershipRefToken = await wallet.submitTx(signedTxOwnershipRefToken);
     * ```
     */
    sendRefScriptOnchain: (scriptIndex: ScriptIndex) => Promise<string>;
    /**
     * [Setup phase]
     * This is the next transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.
     *
     * This transaction creates one content registry. Each registry should comes in pair with one ownership registry and
     * each pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely
     * according to the number of parallelization needed and volumes of content expected to be managed.
     *
     * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.
     * Note: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`
     *
     * @returns {Promise<string>}
     *
     * @example
     * ```typescript
     * const txHex = await contract.createContentRegistry();
     * const signedTx = await wallet.signTx(txHex);
     * const txHash = await wallet.submitTx(signedTx);
     * ```
     */
    createContentRegistry: () => Promise<string>;
    /**
     * [Setup phase]
     * This is the last transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.
     *
     * This transaction creates one content registry. Each registry should comes in pair with one content registry and
     * each pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely
     * according to the number of parallelization needed and volumes of content expected to be managed.
     *
     * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.
     * Note: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`
     *
     * @returns {Promise<string>}
     *
     * @example
     * ```typescript
     * const txHex = await contract.createOwnershipRegistry();
     * const signedTx = await wallet.signTx(txHex);
     * const txHash = await wallet.submitTx(signedTx);
     * ```
     */
    createOwnershipRegistry: () => Promise<string>;
    /**
     * Get the current oracle data.
     *
     * @returns {Promise<{
     *  contentNumber: number,
     *  ownershipNumber: number,
     * }>}
     *
     * @example
     * ```typescript
     * const oracleData = await contract.getOracleData();
     * ```
     */
    getOracleData: () => Promise<{
        contentNumber: number;
        ownershipNumber: number;
    }>;
    /**
     * [User]
     *
     * This transaction mints a user token which can be used to represent the ownership of the content. This token is used in `createContent()` transaction.
     *
     * @param tokenName - The name of the token that you can specify.
     * @param tokenMetadata - The metadata of the token that you can specify.
     * @returns {Promise<string>}
     *
     * @example
     * ```typescript
     * const tx = await contract.mintUserToken("MeshContentOwnership", {
     *   name: "Mesh Content Ownership",
     *   description: "Demo at https://meshjs.dev/smart-contracts/content-ownership",
     * });
     * const signedTx = await wallet.signTx(tx, true);
     * const txHash = await wallet.submitTx(signedTx);
     */
    mintUserToken: (tokenName: string, tokenMetadata?: {}) => Promise<string>;
    /**
     *
     * @param ownerAssetHex
     * @param contentHashHex
     * @param registryNumber
     * @returns
     */
    createContent: (ownerAssetHex: string, contentHashHex: string, registryNumber?: number) => Promise<string>;
    /**
     * Get the content at the registry given the registry number and content number.
     * @param registryNumber
     * @param contentNumber
     * @returns
     */
    getContent: (registryNumber: number, contentNumber: number) => Promise<string>;
    updateContent: ({ ownerTokenUtxo, registryNumber, newContentHashHex, contentNumber, }: UpdateContent) => Promise<string>;
    transferContent: ({ ownerTokenUtxo, registryNumber, newOwnerAssetHex, contentNumber, }: TransferContent) => Promise<string>;
    stopContentRegistry: (registryNumber: number) => Promise<string>;
    stopOwnershipRegistry: (registryNumber: number) => Promise<string>;
    stopOracle: (txInHash: string, txInId: number) => Promise<string>;
    protected getCurrentOracleDatum: (utxos?: UTxO[]) => Promise<OracleDatum>;
    protected getOracleDatum: (contentRegistryCount: number, ownershipRegistryCount: number) => _meshsdk_common.MConStr0<(string | number | _meshsdk_common.MScriptAddress)[]>;
    protected getContentDatum: (contentArray: string[]) => _meshsdk_common.MConStr0<(number | string[])[]>;
    protected getOwnershipDatum: (ownershipArray: [string, string][]) => _meshsdk_common.MConStr0<(number | [string, string][])[]>;
    getScriptUtxos: (registryNumber: number, toFetch?: ("oracle" | "content" | "ownership")[]) => Promise<(UTxO | undefined)[]>;
    private insertContentRegistry;
    private insertOwnershipRegistry;
    private updateContentRegistry;
    private updateOwnershipRegistry;
}

type InitiationDatum = ConStr0$1<[PubKeyAddress, Value]>;
declare const initiateEscrowDatum: (walletAddress: string, amount: Asset[]) => InitiationDatum;
type ActiveEscrowDatum = ConStr1<[
    PubKeyAddress,
    Value,
    PubKeyAddress,
    Value
]>;
declare const activeEscrowDatum: (initiationDatum: InitiationDatum, walletAddress: string, amount: Asset[]) => ActiveEscrowDatum;
type RecipientDepositRedeemer = ConStr0$1<[PubKeyAddress, Value]>;
declare const recipientDepositRedeemer: (recipient: string, depositAmount: Asset[]) => InitiationDatum;
declare class MeshEscrowContract extends MeshTxInitiator {
    scriptCbor: string;
    scriptAddress: string;
    constructor(inputs: MeshTxInitiatorInput);
    getScriptCbor: () => string;
    initiateEscrow: (escrowAmount: Asset[]) => Promise<string>;
    cancelEscrow: (escrowUtxo: UTxO) => Promise<string>;
    recipientDeposit: (escrowUtxo: UTxO, depositAmount: Asset[]) => Promise<string>;
    completeEscrow: (escrowUtxo: UTxO) => Promise<string>;
    getUtxoByTxHash: (txHash: string) => Promise<UTxO | undefined>;
}

declare class MeshGiftCardContract extends MeshTxInitiator {
    tokenNameHex: string;
    paramUtxo: UTxO["input"];
    constructor(inputs: MeshTxInitiatorInput, tokenNameHex?: string, paramUtxo?: UTxO["input"]);
    giftCardCbor: (tokenNameHex: string, utxoTxHash: string, utxoTxId: number) => string;
    redeemCbor: (tokenNameHex: string, policyId: string) => string;
    createGiftCard: (tokenName: string, giftValue: Asset[]) => Promise<string>;
    redeemGiftCard: (giftCardUtxo: UTxO) => Promise<string>;
    getUtxoByTxHash: (txHash: string) => Promise<UTxO | undefined>;
}

type HelloWorldDatum = ConStr0<[
    Integer,
    BuiltinByteString,
    BuiltinByteString
]>;
declare class MeshHelloWorldContract extends MeshTxInitiator {
    scriptCbor: string;
    scriptAddress: string;
    constructor(inputs: MeshTxInitiatorInput);
    getScriptCbor: () => string;
    lockAsset: (assets: Asset[]) => Promise<string>;
    unlockAsset: (scriptUtxo: UTxO, message: string) => Promise<string>;
    getUtxoByTxHash: (txHash: string) => Promise<UTxO | undefined>;
}

type MarketplaceDatum = ConStr0$1<[
    PubKeyAddress,
    Integer$1,
    CurrencySymbol,
    TokenName
]>;
declare const marketplaceDatum: (sellerAddress: string, lovelaceFee: number, assetHex: string) => MarketplaceDatum;
declare class MeshMarketplaceContract extends MeshTxInitiator {
    ownerAddress: string;
    feePercentageBasisPoint: number;
    scriptCbor: string;
    scriptAddress: string;
    constructor(inputs: MeshTxInitiatorInput, ownerAddress: string, feePercentageBasisPoint: number);
    getScriptCbor: (pubKeyHash: string, stakeCredentialHash: string, feePercentageBasisPoint: number) => string;
    listAsset: (asset: string, price: number) => Promise<string>;
    delistAsset: (marketplaceUtxo: UTxO) => Promise<string>;
    purchaseAsset: (marketplaceUtxo: UTxO) => Promise<string>;
    relistAsset: (marketplaceUtxo: UTxO, newPrice: number) => Promise<string>;
    getUtxoByTxHash: (txHash: string) => Promise<UTxO | undefined>;
    static getCompiledCode: (version?: number) => string;
}

declare class MeshPaymentSplitterContract extends MeshTxInitiator {
    scriptCbor: string;
    scriptAddress: string;
    payees: string[];
    wrapPayees: (payees: string[]) => _meshsdk_common.List<_meshsdk_common.BuiltinByteString>;
    constructor(inputs: MeshTxInitiatorInput, payees: string[]);
    getScriptCbor: () => string;
    sendLovelaceToSplitter: (lovelaceAmount: number) => Promise<string>;
    triggerPayout: () => Promise<string>;
}

/**
 * Mesh Plutus NFT contract class
 *
 * This NFT minting script enables users to mint NFTs with an automatically incremented index, which increases by one for each newly minted NFT.
 *
 * To facilitate this process, the first step is to set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence.
 *
 * With each new NFT minted, the token index within the oracle is incremented by one, ensuring a consistent and orderly progression in the numbering of the NFTs.
 */
declare class MeshPlutusNFTContract extends MeshTxInitiator {
    collectionName: string;
    paramUtxo: UTxO["input"];
    oracleAddress: string;
    getOracleCbor: () => string;
    getOracleNFTCbor: () => string;
    getNFTCbor: () => string;
    constructor(inputs: MeshTxInitiatorInput, contract: {
        collectionName: string;
        paramUtxo?: UTxO["input"];
    });
    /**
     * Set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence.
     * @param lovelacePrice - Price of the NFT in lovelace
     * @returns - Transaction hex and paramUtxo
     *
     * @example
     * ```typescript
     * const { tx, paramUtxo } = await contract.setupOracle(lovelacePrice);
     * ```
     */
    setupOracle: (lovelacePrice: number) => Promise<{
        tx: string;
        paramUtxo: {
            outputIndex: number;
            txHash: string;
        };
    }>;
    /**
     * Mint NFT token with an automatically incremented index, which increases by one for each newly minted NFT.
     * @param assetMetadata - Asset metadata
     * @returns - Transaction hex
     *
     * @example
     * ```typescript
     * const assetMetadata = {
     *  ...demoAssetMetadata,
     * name: `Mesh Token ${oracleData.nftIndex}`,
     * };
     * const tx = await contract.mintPlutusNFT(assetMetadata);
     * ```
     */
    mintPlutusNFT: (assetMetadata?: AssetMetadata) => Promise<string>;
    /**
     * Get the current oracle data.
     *
     * @returns - Oracle data
     *
     * @example
     * ```typescript
     * const oracleData = await contract.getOracleData();
     * ```
     */
    getOracleData: () => Promise<{
        nftIndex: number | bigint;
        policyId: string;
        lovelacePrice: number | bigint;
        oracleUtxo: UTxO;
        oracleNftPolicyId: string;
        feeCollectorAddress: string;
        feeCollectorAddressObj: _meshsdk_common.PubKeyAddress;
    }>;
    getUtxoByTxHash: (txHash: string) => Promise<UTxO | undefined>;
}

type SwapDatum = ConStr0$1<[PubKeyAddress, Value, Value]>;
declare class MeshSwapContract extends MeshTxInitiator {
    scriptCbor: string;
    scriptAddress: string;
    constructor(inputs: MeshTxInitiatorInput);
    getScriptCbor: () => string;
    initiateSwap: (toProvide: Asset$1[], toReceive: Asset$1[]) => Promise<string>;
    acceptSwap: (swapUtxo: UTxO$1) => Promise<string>;
    cancelSwap: (swapUtxo: UTxO$1) => Promise<string>;
    getUtxoByTxHash: (txHash: string) => Promise<UTxO$1 | undefined>;
}

type VestingDatum = ConStr0$1<[
    Integer$1,
    BuiltinByteString$1,
    BuiltinByteString$1
]>;
declare class MeshVestingContract extends MeshTxInitiator {
    scriptCbor: string;
    scriptAddress: string;
    constructor(inputs: MeshTxInitiatorInput);
    getScriptCbor: () => string;
    depositFund: (amount: Asset[], lockUntilTimeStampMs: number, beneficiary: string) => Promise<string>;
    withdrawFund: (vestingUtxo: UTxO) => Promise<string>;
    getUtxoByTxHash: (txHash: string) => Promise<UTxO | undefined>;
}

export { type ActiveEscrowDatum, type HelloWorldDatum, type InitiationDatum, type MarketplaceDatum, MeshContentOwnershipContract, MeshEscrowContract, MeshGiftCardContract, MeshHelloWorldContract, MeshMarketplaceContract, MeshPaymentSplitterContract, MeshPlutusNFTContract, MeshSwapContract, MeshVestingContract, type RecipientDepositRedeemer, type SwapDatum, type VestingDatum, activeEscrowDatum, initiateEscrowDatum, marketplaceDatum, recipientDepositRedeemer };
